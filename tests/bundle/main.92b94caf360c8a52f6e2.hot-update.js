exports.id = "main";
exports.modules = {

/***/ "./src/shared/containers/Wallet/functions.js":
/*!***************************************************!*\
  !*** ./src/shared/containers/Wallet/functions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Wallet = undefined;\n\nvar _lunesLib = __webpack_require__(/*! lunes-lib */ \"./node_modules/lunes-lib/index.js\");\n\nvar _satoshiBitcoin = __webpack_require__(/*! satoshi-bitcoin */ \"./node_modules/satoshi-bitcoin/index.js\");\n\nvar _satoshiBitcoin2 = _interopRequireDefault(_satoshiBitcoin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = __webpack_require__(/*! Utils/functions.js */ \"./src/shared/utils/functions.js\"),\n    errorPattern = _require.errorPattern;\n\nvar Wallet = exports.Wallet = function Wallet() {\n\tvar _this = this;\n\n\t_classCallCheck(this, Wallet);\n\n\tthis.getCoinsPrice = function () {\n\t\tvar _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data) {\n\t\t\tvar coinsPrice, coinKey;\n\t\t\treturn regeneratorRuntime.wrap(function _callee$(_context) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tswitch (_context.prev = _context.next) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t_context.prev = 0;\n\t\t\t\t\t\t\tcoinsPrice = {};\n\t\t\t\t\t\t\t_context.t0 = regeneratorRuntime.keys(data);\n\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tif ((_context.t1 = _context.t0()).done) {\n\t\t\t\t\t\t\t\t_context.next = 10;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcoinKey = _context.t1.value;\n\t\t\t\t\t\t\t_context.next = 7;\n\t\t\t\t\t\t\treturn _lunesLib.coins.getPrice(data[coinKey]);\n\n\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\tcoinsPrice[data[coinKey].fromSymbol.toLowerCase()] = _context.sent;\n\t\t\t\t\t\t\t_context.next = 3;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 10:\n\t\t\t\t\t\t\treturn _context.abrupt('return', coinsPrice);\n\n\t\t\t\t\t\tcase 13:\n\t\t\t\t\t\t\t_context.prev = 13;\n\t\t\t\t\t\t\t_context.t2 = _context['catch'](0);\n\t\t\t\t\t\t\treturn _context.abrupt('return', errorPattern('Error on trying to get price', 500, 'COINGETPRICE_ERROR', _context.t2));\n\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\tcase 'end':\n\t\t\t\t\t\t\treturn _context.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, _callee, _this, [[0, 13]]);\n\t\t}));\n\n\t\treturn function (_x) {\n\t\t\treturn _ref.apply(this, arguments);\n\t\t};\n\t}();\n\n\tthis.getUserAddresses = function (user) {\n\t\ttry {\n\t\t\tvar addresses = {};\n\t\t\t//(example): @param coin = {symbol: 'btc', createdAt: [timestamp], etc..} \n\t\t\tuser.wallet.coins.map(function (coin) {\n\t\t\t\t//if addresses does not have {addresses['btc'] (example)} as attribute, so:\n\t\t\t\tif (!addresses[coin.symbol]) {\n\t\t\t\t\taddresses[coin.symbol] = [];\n\t\t\t\t}\n\t\t\t\t//we get the ${addresses[coin.symbol]} array, and we push an address to it\n\t\t\t\tcoin.addresses.map(function (obj) {\n\t\t\t\t\taddresses[coin.symbol].push(obj.address);\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn addresses;\n\t\t} catch (err) {\n\t\t\treturn errorPattern('Was not possible get user addresses', 500, 'WALLET_GETUSERADDRESS_ERROR', err);\n\t\t}\n\t};\n\n\tthis.getBalance = function () {\n\t\tvar _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(user) {\n\t\t\tvar coinsPrice, addresses, balance, token, coin, i, addressKey, address, response;\n\t\t\treturn regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tswitch (_context2.prev = _context2.next) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t_context2.prev = 0;\n\t\t\t\t\t\t\t_context2.next = 3;\n\t\t\t\t\t\t\treturn _this.getCoinsPrice([{ fromSymbol: 'BTC', toSymbol: 'BRL,USD' }, { fromSymbol: 'LTC', toSymbol: 'BRL,USD' }, { fromSymbol: 'ETH', toSymbol: 'BRL,USD' }]);\n\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tcoinsPrice = _context2.sent;\n\t\t\t\t\t\t\taddresses = _this.getUserAddresses(user);\n\t\t\t\t\t\t\tbalance = {};\n\t\t\t\t\t\t\ttoken = user.accessToken;\n\t\t\t\t\t\t\t//coin = 'btc' (example)\n\n\t\t\t\t\t\t\t_context2.t0 = regeneratorRuntime.keys(addresses);\n\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tif ((_context2.t1 = _context2.t0()).done) {\n\t\t\t\t\t\t\t\t_context2.next = 23;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcoin = _context2.t1.value;\n\n\t\t\t\t\t\t\t//addressKey = 1 (example)\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\t_context2.t2 = regeneratorRuntime.keys(addresses[coin]);\n\n\t\t\t\t\t\tcase 12:\n\t\t\t\t\t\t\tif ((_context2.t3 = _context2.t2()).done) {\n\t\t\t\t\t\t\t\t_context2.next = 21;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\taddressKey = _context2.t3.value;\n\n\t\t\t\t\t\t\t//it gets the current addres of the iteration\n\t\t\t\t\t\t\taddress = addresses[coin][addressKey];\n\t\t\t\t\t\t\t//it returns a response object\n\n\t\t\t\t\t\t\t_context2.next = 17;\n\t\t\t\t\t\t\treturn _lunesLib.coins.bitcoin.getBalance({ address: address }, token);\n\n\t\t\t\t\t\tcase 17:\n\t\t\t\t\t\t\tresponse = _context2.sent;\n\n\t\t\t\t\t\t\tif (response.status === 'success') {\n\t\t\t\t\t\t\t\tif (!balance[coin]) {\n\t\t\t\t\t\t\t\t\tbalance[coin] = {};\n\t\t\t\t\t\t\t\t\tbalance[coin]['total_confirmed'] = _satoshiBitcoin2.default.toSatoshi(0);\n\t\t\t\t\t\t\t\t\tbalance[coin]['total_unconfirmed'] = _satoshiBitcoin2.default.toSatoshi(0);\n\t\t\t\t\t\t\t\t\tbalance[coin]['amount'] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//it sums the old total_confirmed with the new\n\t\t\t\t\t\t\t\tbalance[coin]['total_confirmed'] += _satoshiBitcoin2.default.toSatoshi(response.data.confirmed_balance);\n\t\t\t\t\t\t\t\tbalance[coin]['total_unconfirmed'] += _satoshiBitcoin2.default.toSatoshi(response.data.unconfirmed_balance);\n\t\t\t\t\t\t\t\t//it converts total_confirmed to bitcoin\n\t\t\t\t\t\t\t\tbalance[coin]['total_unconfirmed'] = _satoshiBitcoin2.default.toBitcoin(balance[coin]['total_unconfirmed']);\n\t\t\t\t\t\t\t\tbalance[coin]['total_confirmed'] = _satoshiBitcoin2.default.toBitcoin(balance[coin]['total_confirmed']);\n\t\t\t\t\t\t\t\tbalance[coin]['amount'] = balance[coin]['total_confirmed'] * coinsPrice[coin]['USD'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_context2.next = 12;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 21:\n\t\t\t\t\t\t\t_context2.next = 8;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 23:\n\t\t\t\t\t\t\treturn _context2.abrupt('return', balance);\n\n\t\t\t\t\t\tcase 26:\n\t\t\t\t\t\t\t_context2.prev = 26;\n\t\t\t\t\t\t\t_context2.t4 = _context2['catch'](0);\n\t\t\t\t\t\t\treturn _context2.abrupt('return', errorPattern('Error on get balance', 500, 'WALLET_GETBALANCE_ERROR', _context2.t4));\n\n\t\t\t\t\t\tcase 29:\n\t\t\t\t\t\tcase 'end':\n\t\t\t\t\t\t\treturn _context2.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, _callee2, _this, [[0, 26]]);\n\t\t}));\n\n\t\treturn function (_x2) {\n\t\t\treturn _ref2.apply(this, arguments);\n\t\t};\n\t}();\n};\n\nWallet.coinsPrice = {};\n;\n\n//# sourceURL=webpack:///./src/shared/containers/Wallet/functions.js?");

/***/ })

};